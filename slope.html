<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Neon Slope Clone</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
<script>
  // Scene, camera, renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const ambient = new THREE.AmbientLight(0x404040);
  scene.add(ambient);
  const point = new THREE.PointLight(0xffffff, 1);
  point.position.set(0, 5, 0);
  scene.add(point);

  // Ball
  const ballGeometry = new THREE.SphereGeometry(1, 32, 32);
  const ballMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
  const ball = new THREE.Mesh(ballGeometry, ballMaterial);
  scene.add(ball);

  // Tunnel geometry: build a series of ring segments
  const tunnel = new THREE.Group();
  scene.add(tunnel);

  const ringCount = 100;
  const ringRadius = 5;
  const ringThickness = 0.5;
  const ringSpacing = 1; // distance between rings

  for (let i = 0; i < ringCount; i++) {
    const geometry = new THREE.TorusGeometry(ringRadius, ringThickness, 8, 100);
    const material = new THREE.MeshBasicMaterial({
      color: i % 2 === 0 ? 0x00ff00 : 0xff0000,
      side: THREE.DoubleSide,
    });
    const ring = new THREE.Mesh(geometry, material);
    ring.rotation.x = Math.PI / 2;
    ring.position.z = -i * ringSpacing;
    tunnel.add(ring);
  }

  // Controls
  let steer = 0;
  window.addEventListener("keydown", (e) => {
    if (e.key === "a" || e.key === "ArrowLeft") steer = -1;
    if (e.key === "d" || e.key === "ArrowRight") steer = 1;
  });
  window.addEventListener("keyup", (e) => {
    if ((e.key === "a" || e.key === "ArrowLeft") && steer === -1) steer = 0;
    if ((e.key === "d" || e.key === "ArrowRight") && steer === 1) steer = 0;
  });

  // Game parameters
  let speed = 0.2;
  let lateralSpeed = 0.05;

  // Resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  camera.position.z = 2;
  camera.position.y = 1;

  function animate() {
    requestAnimationFrame(animate);

    // Move tunnel forward (simulate ball moving forward)
    tunnel.children.forEach((ring) => {
      ring.position.z += speed;
      if (ring.position.z > camera.position.z + 2) {
        // recycle ring: send it back
        ring.position.z = tunnel.children[tunnel.children.length - 1].position.z - ringSpacing;
      }
    });

    // Steer the ball (move lateral)
    ball.position.x += steer * lateralSpeed;

    // Boundaries: keep ball inside tunnel radius
    const maxX = ringRadius - ringThickness - 0.5;
    if (ball.position.x > maxX) ball.position.x = maxX;
    if (ball.position.x < -maxX) ball.position.x = -maxX;

    // Make camera follow ball a little
    camera.position.x = ball.position.x * 0.5;
    camera.lookAt(ball.position.x, ball.position.y, ball.position.z - 5);

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
