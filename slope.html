<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Slope-style 3-in-1 (Fixed)</title>
<style>
  html,body { height:100%; margin:0; background:#000; color:#fff; font-family:Arial; overflow:hidden;}
  #ui { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; background:rgba(0,0,0,0.75); z-index:5;}
  .menu { display:flex; gap:12px; flex-direction:column; align-items:center;}
  button { padding:12px 20px; font-size:18px; border-radius:8px; border:2px solid #44ff88; background:#001100; color:#aaffbd; cursor:pointer;}
  #hud { position:absolute; left:12px; top:12px; z-index:4; font-size:18px; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px;}
  #overlayMsg { position:absolute; right:12px; top:12px; z-index:4; font-size:18px; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px;}
</style>
</head>
<body>
<div id="ui">
  <div class="menu">
    <h1>3-in-1 Slope-style</h1>
    <div>Select mode</div>
    <button onclick="start('tunnel')">Neon Tunnel</button>
    <button onclick="start('classic')">Classic Slope</button>
    <button onclick="start('hybrid')">Hybrid</button>
    <div style="margin-top:10px; font-size:13px; color:#ccc">Controls: A / D or ← / → — R to restart</div>
  </div>
</div>

<div id="hud" style="display:none">Distance: <span id="dist">0</span></div>
<div id="overlayMsg" style="display:none"></div>

<!-- Three.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>

<script>
(() => {
  // Globals
  let renderer, scene, camera, ball;
  let objects = []; // platforms / tunnel parts
  let mode = null;
  let steer = 0;
  let running = false;
  let distance = 0;
  let speed = 0.32;            // forward motion speed (higher -> faster)
  let lateralSpeed = 0.12;     // left-right movement speed
  let gravity = -0.02;
  let ballVY = 0;
  let lastTime = performance.now();

  const ui = document.getElementById('ui');
  const hud = document.getElementById('hud');
  const distEl = document.getElementById('dist');
  const overlay = document.getElementById('overlayMsg');

  // Prevent multiple renderers if user restarts
  function cleanPrevious() {
    if (renderer) {
      try {
        renderer.forceContextLoss();
      } catch(e){}
      if (renderer.domElement && renderer.domElement.parentNode) {
        renderer.domElement.parentNode.removeChild(renderer.domElement);
      }
      renderer = null;
    }
    // remove any previous event handlers? (we attach only once)
    objects = [];
    if (scene) {
      scene = null;
    }
    ball = null;
    distance = 0;
    speed = 0.32;
    ballVY = 0;
    steer = 0;
    running = false;
    overlay.style.display = 'none';
  }

  // Start game with mode
  window.start = (m) => {
    cleanPrevious();
    mode = m;
    ui.style.display = 'none';
    hud.style.display = 'block';
    initThree();
    createWorld();
    lastTime = performance.now();
    running = true;
    animate();
  };

  // Initialize Three.js
  function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 2.2, 6);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // basic lights
    const amb = new THREE.AmbientLight(0x404040, 0.9);
    scene.add(amb);
    const pl = new THREE.PointLight(0xffffff, 0.7);
    pl.position.set(0,5,3);
    scene.add(pl);

    // make subtle fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.003);
  }

  // Create player (ball)
  function createBall() {
    const geom = new THREE.SphereGeometry(0.9, 24, 24);
    const mat = new THREE.MeshStandardMaterial({ color:0x00ff88, emissive:0x00ff88, emissiveIntensity:0.6, roughness:0.4});
    ball = new THREE.Mesh(geom, mat);
    ball.castShadow = true;
    ball.position.set(0,1.2,0);
    scene.add(ball);
  }

  // Utility to create a platform box
  function makePlatform(w=10, h=0.6, d=18, color=0x00ff00) {
    const g = new THREE.BoxGeometry(w,h,d);
    const m = new THREE.MeshBasicMaterial({ color: color });
    const mesh = new THREE.Mesh(g,m);
    mesh.receiveShadow = true;
    return mesh;
  }

  // Utility to create a tunnel ring (thin torus)
  function makeRing(radius=7, thickness=0.5, color=0x00ff00) {
    const g = new THREE.TorusGeometry(radius, thickness, 8, 80);
    const m = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(g,m);
    mesh.rotation.x = Math.PI/2;
    return mesh;
  }

  // Create world depending on mode(s)
  function createWorld() {
    createBall();

    if (mode === 'classic' || mode === 'hybrid') {
      // create platforms descending in z and y like slope
      const count = 80;
      for (let i=0;i<count;i++) {
        const c = (i%2===0) ? 0x00ff00 : 0xff0044;
        const p = makePlatform(12, 0.6, 20, c);
        p.position.z = -i * 18 - 10;
        p.position.y = -i * 0.8; // downhill feel
        // small x offset pattern to vary
        p.userData = { type:'platform' };
        objects.push(p);
        scene.add(p);
      }
    }

    if (mode === 'tunnel' || mode === 'hybrid') {
      // create torus rings forming a tunnel; if hybrid, offset them further
      const count = 140;
      const baseZ = (mode==='hybrid') ? -1200 : 0;
      for (let i=0;i<count;i++) {
        const c = (i%2===0) ? 0x00ff00 : 0xff0044;
        const r = makeRing(8, 0.5, c);
        r.position.z = baseZ - i * 6;
        r.position.y = -50; // below platforms so ball travels "inside"
        r.userData = { type:'ring' };
        objects.push(r);
        scene.add(r);
      }

      // Create subtle neon wall planes to give tunnel depth (optional)
      const wallCount = 24;
      for (let j=0;j<wallCount;j++){
        const geom = new THREE.PlaneGeometry(30, 10);
        const mat = new THREE.MeshBasicMaterial({ color: 0x003300, transparent:true, opacity:0.06, side:THREE.DoubleSide });
        const wall = new THREE.Mesh(geom, mat);
        wall.position.z = -400 - j*40;
        wall.rotation.y = j%2 ? 0.2 : -0.2;
        scene.add(wall);
        objects.push(wall);
      }
    }
  }

  // Input
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'a' || e.key === 'ArrowLeft') steer = -1;
    if (e.key === 'd' || e.key === 'ArrowRight') steer = 1;
    if (e.key === 'r' || e.key === 'R') restart();
  });
  window.addEventListener('keyup', (e)=>{
    if ((e.key === 'a' || e.key === 'ArrowLeft') && steer === -1) steer = 0;
    if ((e.key === 'd' || e.key === 'ArrowRight') && steer === 1) steer = 0;
  });

  // Simple collision: ball vs ring edges (if too far x, it's a hit)
  function checkCollision() {
    // boundary depending on tunnel radius or platform width
    const tunnelRadius = 7.6;
    if (mode === 'tunnel') {
      if (Math.abs(ball.position.x) > tunnelRadius - 0.9) return true;
    } else if (mode === 'classic') {
      // if ball falls below platforms too far -> crash
      if (ball.position.y < -100) return true;
    } else if (mode === 'hybrid') {
      if (Math.abs(ball.position.x) > tunnelRadius - 0.9 && ball.position.z < -200) return true;
      if (ball.position.y < -200) return true;
    }
    return false;
  }

  // Restart function
  function restart() {
    // remove existing scene objects and re-create world; keep same mode
    if (!mode) return;
    // clear scene
    if (scene) {
      // remove children that we added (leave lights if any—simpler to reload)
      while(scene.children.length>0) scene.remove(scene.children[0]);
    }
    objects = [];
    createBall();
    createWorld();
    distance = 0;
    speed = 0.32;
    ballVY = 0;
    overlay.style.display = 'none';
    running = true;
  }

  // End game handler
  function gameOver(msg) {
    running = false;
    overlay.style.display = 'block';
    overlay.innerText = msg + "\nPress R to restart";
  }

  // Main loop
  function animate() {
    if (!renderer) return;
    requestAnimationFrame(animate);

    const now = performance.now();
    const dt = Math.min((now - lastTime) / 16.6667, 4); // normalized steps
    lastTime = now;
    if (!running) {
      renderer.render(scene, camera);
      return;
    }

    // move ball lateral with easing
    ball.position.x += steer * lateralSpeed * dt;

    // simple pseudo-gravity & bounce on platforms (only for classic/hybrid)
    if (mode === 'classic' || mode === 'hybrid') {
      ballVY += gravity * dt;
      ball.position.y += ballVY * dt;
      // raycast down to find nearby platform under ball
      let landed = false;
      for (let obj of objects) {
        if (!obj.userData) continue;
        if (obj.userData.type !== 'platform') continue;
        // approximate collision: check if ball.z close to platform.z and x within width
        const dz = Math.abs((ball.position.z) - (obj.position.z));
        if (dz < 10) {
          const relativeX = ball.position.x - obj.position.x;
          if (Math.abs(relativeX) < 6) {
            const platformTopY = obj.position.y + 0.6/2 + 0.9; // top + ball radius
            if (ball.position.y <= platformTopY && ballVY <= 0) {
              // land
              ball.position.y = platformTopY;
              ballVY = 0;
              landed = true;
            }
          }
        }
      }
      if (!landed && ball.position.y < -400) {
        gameOver("You fell off the track!");
      }
    }

    // move world objects forward (increase z)
    for (let obj of objects) {
      // different recycling rules for rings and platforms
      obj.position.z += speed * dt * 16.6667;

      if (obj.userData && obj.userData.type === 'ring') {
        // if ring passes camera, recycle to back
        if (obj.position.z > camera.position.z + 6) {
          obj.position.z = getFarthestZ() - 6;
        }
      } else if (obj.userData && obj.userData.type === 'platform') {
        // recycle platforms by moving them far back and slightly randomizing x/y
        if (obj.position.z > camera.position.z + 10) {
          obj.position.z = getFarthestZ() - 18 - Math.random()*6;
          obj.position.x = (Math.random()-0.5) * 6;
          obj.position.y -= 0.8; // keep downhill slope feel
        }
      } else {
        // generic objects like decorative walls
        if (obj.position.z > camera.position.z + 50) {
          obj.position.z = getFarthestZ() - 50;
        }
      }
    }

    // increase difficulty over distance
    distance += speed * dt * 1.2;
    if (distance % 500 < 1) { // small surges
      speed = Math.min(1.6, speed + 0.005);
    }

    // update camera to follow ball
    camera.position.x += (ball.position.x * 0.45 - camera.position.x) * 0.12;
    camera.position.y += ((ball.position.y + 1.6) - camera.position.y) * 0.08;
    camera.position.z = ball.position.z + 6;
    camera.lookAt(ball.position.x, ball.position.y, ball.position.z - 8);

    // collision check
    if (checkCollision()) {
      gameOver("You hit the wall!");
    }

    // update HUD
    distEl.innerText = Math.floor(distance);

    renderer.render(scene, camera);
  }

  function getFarthestZ() {
    let far = -Infinity;
    for (let o of objects) {
      if (o.position.z < far) far = o.position.z;
      if (o.position.z < -1e8) o.position.z = -1000; // sanity
      if (o.position.z < far) far = o.position.z;
    }
    // if no objects or far is Infinity, return -800
    if (!objects.length || far === -Infinity) return -800;
    return far;
  }

  // handle resize
  window.addEventListener('resize', ()=>{
    if (!camera || !renderer) return;
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // show initial instructions overlay if threat removed (we already warned above)
  overlay.style.display = 'none';

})(); // IIFE
</script>
</body>
</html>
